<template>
  <div class="_container">
    <div v-if="!ifActivityWasAdded">
      <div class="form-container">
        <!-- Error alert -->
        <div v-if="exceptionMessage !== '' ">
          <v-alert
              :title="exceptionTitle"
              :text="exceptionMessage"
              type="error"
          ></v-alert>
        </div>
        <form>
          <h2 class="form-header">Create an activity</h2>
          <div class="flex-container">
            <div class="left-group-container">
              <!--activityName-->
              <div class="form-item-container">
                <v-text-field
                    v-model="activityName.value.value"
                    :counter="50"
                    :error-messages="activityName.errorMessage.value"
                    label="Activity name"
                    variant="solo"
                    density="compact"
                ></v-text-field>
              </div>

              <!-- Categories selector  -->
              <div class="form-item-container">
                <v-autocomplete
                    label="Category"
                    v-model="activityCategory.value.value"
                    :items="artCategories"
                    :error-messages="activityCategory.errorMessage.value"
                    variant="solo"
                    density="compact"
                ></v-autocomplete>
              </div>

              <!--   Cities selector-->
              <div class="form-item-container">
                <v-autocomplete
                    label="City"
                    v-model="activityCity.value.value"
                    @change="showCityOnMap"
                    :items="citiesDataArray"
                    :error-messages="activityCity.errorMessage.value"
                    variant="solo"
                    density="compact"
                ></v-autocomplete>
              </div>

              <!--   Street input -->
              <div class="form-item-container">
                <v-text-field
                    v-model="activityStreet.value.value"
                    @change="showCityAndStreetOnMap"
                    :counter="50"
                    :error-messages="activityStreet.errorMessage.value"
                    label="Street"
                    variant="solo"
                    density="compact"
                ></v-text-field>
              </div>

              <!--   HouseNumber input -->
              <div class="form-item-container">
                <v-text-field
                    v-model="activityHouseNumber.value.value"
                    @change="showCityAndStreetAndHouseOnMap"
                    label="House number (optional)"
                    variant="solo"
                    :counter="5"
                    density="compact"
                ></v-text-field>
              </div>
            </div>

            <!-- Map component -->
            <div class="leafletMapContainer">
               <LMap class="leafletMap" style="height: 100%; width: 100%" :zoom="mapZoom" :center="[mapCenterLat, mapCenterLng]">
                 <LTileLayer
                     url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
                     attribution="&amp;copy; <a href=&quot;https://www.openstreetmap.org/&quot;>OpenStreetMap</a> contributors"
                     layer-type="base"
                     name="OpenStreetMap"
                 />
                 <LMarker v-if="showMarker" :lat-lng="[markerLat, markerLng]" draggable @dragend="updateMarkerLatLng" />
               </LMap>
            </div>
          </div>

          <!--  activityDateTime   -->
          <div class="form-datepicker-container">
            <add-activity-date-picker-component></add-activity-date-picker-component>
            <p class="my-error-message" v-if="activityDates.errorMessage.value && datesList.length === 0">{{activityDates.errorMessage.value}}</p>
          </div>

          <!-- activityDescription -->
          <div class="form-item-container">
            <v-textarea
                label="Describe your activity"
                v-model="activityDescription.value.value"
                :error-messages="activityDescription.errorMessage.value"
                variant="solo"
                :counter="1500"
            >
            </v-textarea>
          </div>

          <!-- activityMainPhoto -->
          <div class="form-item-container">
            <v-file-input
                label="Main photo to describe activity"
                @input="setMainActivityImage"
                v-model="activityMainPhoto.value.value"
                :error-messages="activityMainPhoto.errorMessage.value"
                accept="image/*"
                variant="solo"
                chips
                density="compact"
                show-size
            ></v-file-input>
          </div>

          <!-- activityAdditionalPhotos -->
          <div class="form-item-container">
            <v-file-input
                label="Additional photos (max 5, optional)"
                @input="setAdditionalActivityImage"
                v-model="activityAdditionalPhotos.value.value"
                :error-messages="activityAdditionalPhotos.errorMessage.value"
                accept="image/*"
                variant="solo"
                chips
                multiple
                counter
                density="compact"
            ></v-file-input>
          </div>

          <!-- submitBTN -->
          <v-btn
              class="me-4 submit-button"
              :loading="isActivityCreating"
              @click="submit"
          >
            create an activity
          </v-btn>
        </form>
      </div>
    </div>
    <div v-else class="activity-added-container">
      <div class="activity-added-img">
        <img class="form-added-success-img" src="/images/success_icon.png" alt="success">
      </div>
      <h2>Success!</h2>
      <h5>Activity was added</h5>
      <v-btn
          class="link-button"
      >
        <NuxtLink to="/admin/myActivities" class="link-item">go to my activities</NuxtLink>
      </v-btn>
    </div>
  </div>
</template>

<script setup>
import '@vuepic/vue-datepicker/dist/main.css';
import {useField, useForm} from 'vee-validate'
import { collection, addDoc } from "firebase/firestore";
import { getStorage, ref as storageRef, uploadBytes } from "firebase/storage";
import {useDateListStore} from "~/stores/datesList";

// firebase
const { $firestore } = useNuxtApp()
const storage = getStorage()
const userUidCookie = useCookie('userUidCookie')
const userUid = userUidCookie.value

// activity was added
const ifActivityWasAdded = ref(false)

// map configuration
const mapZoom = ref(6);
const mapCenterLat = ref(52.215933);
const mapCenterLng = ref(19.134422);
const showMarker = ref(false);
const markerLat = ref();
const markerLng = ref();
const exceptionMessage = ref('');
const exceptionTitle = ref('');

// activity categories
const artCategoriesList = await getArtCategoriesList();
const artCategories = computed(() => {
  return artCategoriesList.map(item => item.name);
})

// activity cities
const citiesDataJSON = await getCitiesData()

// citiesDataArray to autocomplete
const citiesDataArray = computed(() =>{
  return citiesDataJSON.map(city => city.name + ', ' + city.admin_name)
});

// datePicker variables
const dateListStore = useDateListStore();
dateListStore.datesList.length = 0
const datesList = dateListStore.datesList;
const dateListStartEndArray = reactive([]);

// activity photos
const activityMainPhotoFile = ref();
const activityAdditionalPhotoesFiles = ref([]);

const isActivityCreating = ref(false);

// validation rules
const {handleSubmit, handleReset} = useForm({
  validationSchema: {
    name (value) {
      if (value?.length <= 2) return 'Name needs to be at least 3 characters.'
      if (value?.length > 50) return 'Enter max 50 characters.'

      return true
    },
    dates(){
      if (datesList.length > 0) return true

      return 'Select at least 1 date'
    },
    category (value) {
      if (value) return true

      return 'Select a category please'
    },
    city (value) {
      if (value) return true

      return 'Select a city please'
    },
    description (value) {
      if (value?.length <= 2)  return 'Description must have at least 3 characters'
      if (value?.length > 1500)  return 'Description must have max 1500 characters'

      return true
    },
    mainPhoto (value) {
      if (value) return true

      return 'Select a photo please'
    },
    additionalPhotos (value) {
      if (!value || value?.length <= 5) return true

      return 'Max number of photos is 5'
    },
    street (value){
      if(value?.length >= 3 && value?.length <= 50) return true;

      return 'Please enter valid street'
    },
    houseNumber (value) {
      if(value?.length < 6) return true;

      return 'Max house number length is 5'
    }
  },
})
const activityName = useField('name');
const activityDates = useField('dates');
const activityCategory = useField('category');
const activityCity = useField('city');
const activityDescription = useField('description');
const activityMainPhoto = useField('mainPhoto');
const activityAdditionalPhotos = useField('additionalPhotos');
const activityStreet = useField('street');
const activityHouseNumber = useField('houseNumber');

const submit = handleSubmit(async () => {
  isActivityCreating.value = true
  await addActivity()
});

async function addActivity() {
  const activityCityData = await getActivityCityData();

  // send photos to Storage
  const uniqueKey  = new Date();
  const mainPhotoRef = await addMainActivityPhoto(uniqueKey);
  const arrayOfAdditionalPhotosRefs = await addAdditionalActivityPhotos(uniqueKey);
  if(!processDateList()) return;

  // send data to Firebase
  await addDoc(collection($firestore, "activities"), {
    artistUid: userUid,
    name: activityName.value.value.trim(),
    activityDates: dateListStartEndArray,
    activityEnd: dateListStartEndArray[dateListStartEndArray.length - 1].end,
    category: activityCategory.value.value,
    // city coordinates
    cityName: activityCityData.name,
    cityAdmin: activityCityData.admin_name,
    coordinatesLat: markerLat.value,
    coordinatesLng: markerLng.value,
    // street and house info
    streetName: activityStreet.value.value.trim(),
    houseNumber: activityHouseNumber.value.value !== undefined && activityHouseNumber.value.value !== '' ? activityHouseNumber.value.value : null,
    description: activityDescription.value.value.trim(),
    mainPhotoRef: mainPhotoRef,
    additionalPhotosRefs: arrayOfAdditionalPhotosRefs,
  });

  isActivityCreating.value = false
  ifActivityWasAdded.value = true;
}

function processDateList() {
  dateListStartEndArray.length = 0;

  if (datesList.length > 0){
    for(let i = 0; i < datesList.length; i++){
      const startDate = datesList[i].dateStart;
      const endDate = datesList[i].dateEnd;

      const timeStart = datesList[i].timeStart;
      const timeEnd = datesList[i].timeEnd;

      if (timeStart && timeEnd) {
        const startDateTime = startDate.setHours(timeStart.hours, timeStart.minutes, timeStart.seconds);
        const endDateTime = endDate.setHours(timeEnd.hours, timeEnd.minutes, timeEnd.seconds);

        dateListStartEndArray.push({
          start: startDateTime,
          end: endDateTime,
        });
      }else{
        const unChosenTime = new Date(datesList[i].dateStart);

        exceptionTitle.value = `Unselected time start or time end`;
        exceptionMessage.value = `Please select timeStart and timeEnd for ${unChosenTime.toDateString()}`;
        scrollToTop();

        return false;
      }
    }
  } else {
    exceptionTitle.value = `Unselected activity date`;
    exceptionMessage.value = `Please select at least 1 date to your activity`;
    scrollToTop();

    return false;
  }

  exceptionTitle.value = '';
  exceptionMessage.value = '';

  return true;
}

// todo: add to storage
async function addMainActivityPhoto(uniqueKey) {
  // Create a reference to 'images/activityPhoto ...'
  const url =  'images/' + 'activityPhoto' + activityName.value.value.trim() + uniqueKey.toString();
  const activityPhotoRef = storageRef(storage, url);
  await uploadBytes(activityPhotoRef, activityMainPhotoFile.value);

  return url
}

// todo: add to storage
async function addAdditionalActivityPhotos(uniqueKey){
  let urlsArray = [];

  if(activityAdditionalPhotoesFiles.value.length > 0){
    for(let i = 0; i < activityAdditionalPhotoesFiles.value.length; i++) {
      const url = 'images/' + 'additionalPhoto' + i.toString() + activityName.value.value.trim() + uniqueKey.toString();
      urlsArray.push(url);
      const activityPhotoRef = storageRef(storage, url);
      await uploadBytes(activityPhotoRef, activityAdditionalPhotoesFiles.value[i]);
    }
  }
  return urlsArray;
}

// todo: add to storage
async function getCitiesData(){
  // отримую дані від сервера
  const { data } = await useFetch('/api/citiesList');
  // повертаю - тільки потрібний масив данних: citiesListData
  return data.value.sortedCitiesListData;
}

// todo: add to storage
async function getArtCategoriesList(){
  // отримую дані від сервера
  const { data } = await useFetch('/api/artCategoriesList');
  // повертаю - тільки потрібний масив данних:
  return data.value.artCategoriesList;
}

// todo: add to storage
function getActivityCityData(){
  const cityData = activityCity.value.value;
  const parts = cityData.split(", ");

  const cityName = parts[0];
  const cityAdminName = parts[1];

  return  citiesDataJSON.find(city => {
    return city.name === cityName && city.admin_name === cityAdminName
  });
}

function setMainActivityImage(event){
  activityMainPhotoFile.value = event.target.files[0];
}

function setAdditionalActivityImage(event){
  if(event.target.files.length > 0 && event.target.files.length <= 5){
    activityAdditionalPhotoesFiles.value = event.target.files;
  }
}

function scrollToTop() {
  document.documentElement.scrollTop = 0 // For modern browsers
  document.body.scrollTop = 0 // For older browsers
}

// todo: add to storage
async function showCityOnMap(){
  try {
    const cityData = activityCity.value.value;
    // Розділення рядка за допомогою коми та пробілу
    const [city, district] = cityData.split(", ");
    // запит до API для отримання координат міста
    const response  = await fetch(`https://geocode.maps.co/search?q=${city}+${district}+Poland&api_key=659450539ff1f762862410sea796255`);
    const data = await response.json();

    // Якщо результати є, беремо перший результат
    if (data.length > 0) {
      const activityCoordinates = data[0];

      mapCenterLat.value = Number(activityCoordinates.lat);
      mapCenterLng.value = Number(activityCoordinates.lon);
      mapZoom.value = 12;
      activityStreet.value.value = '';
      activityHouseNumber.value.value = '';
    }
  } catch (error) {
    // Обробка помилок, наприклад, у випадку невдалих запитів до API
    console.log('Error during fetching data for mapCenter from geocode.maps API:', error);
  }
}

// todo: add to storage
async function showCityAndStreetOnMap(){
  if(activityCity.value.value !== undefined && activityCity.value.value !== ''){
    try {
      const cityData = activityCity.value.value;
      const [city, district] = cityData.split(", ");
      // запит до API для отримання координат міста та вулиці
      const response  = await fetch(`https://geocode.maps.co/search?q=${activityStreet.value.value.trim()}+${city}+${district}+Poland&api_key=659450539ff1f762862410sea796255`);
      const data = await response.json();

      // Якщо результати є, беремо перший результат
      if (data.length > 0) {
        const activityCoordinates = data[0];

        mapCenterLat.value = Number(activityCoordinates.lat);
        mapCenterLng.value = Number(activityCoordinates.lon);
        markerLat.value = mapCenterLat.value;
        markerLng.value = mapCenterLng.value;
        showMarker.value = true;
        mapZoom.value = 17;

        activityHouseNumber.value.value = '';
        exceptionTitle.value = '';
        exceptionMessage.value = '';
      }else{ // якщо не знайдено координати
        exceptionTitle.value = `No such street in ${activityCity.value.value}`;
        exceptionMessage.value = `Please enter valid street name.`;
        scrollToTop();
      }
    } catch (error) {
      // Обробка помилок, наприклад, у випадку невдалих запитів до API
      console.log('Error during fetching data for mapCenter from geocode.maps API:', error);
      exceptionTitle.value = `No such street in ${activityCity.value.value}`;
      exceptionMessage.value = `Please enter valid street name.`;
      scrollToTop();
    }
  }else{ // якщо не обрано місто
    activityCity.value.value = '';
    activityStreet.value.value = '';
    exceptionTitle.value = `Unselected city`;
    exceptionMessage.value = 'Select city, then input street name';
    scrollToTop();
  }
}

// todo: add to storage
async function showCityAndStreetAndHouseOnMap(){
  if(activityCity.value.value !== undefined && activityCity.value.value !== '' && activityStreet.value.value !== undefined && activityStreet.value.value !== ''){
    try {
      const cityData = activityCity.value.value;
      const [city, district] = cityData.split(", ");
      // запит до API для отримання координат міста та вулиці
      const response  = await fetch(`https://geocode.maps.co/search?street=${activityStreet.value.value.trim()}+${activityHouseNumber.value.value.trim()}&city=${city}&country=Poland&api_key=659450539ff1f762862410sea796255`);
      const data = await response.json();

      // Якщо результати є, беремо перший результат
      if (data.length > 0) {
        const activityCoordinates = data[0];

        mapCenterLat.value = Number(activityCoordinates.lat);
        mapCenterLng.value = Number(activityCoordinates.lon);
        markerLat.value = mapCenterLat.value;
        markerLng.value = mapCenterLng.value
        showMarker.value = true;
        mapZoom.value = 17;

        exceptionTitle.value = '';
        exceptionMessage.value = '';
      }else{
        exceptionTitle.value = `No such house number in ${activityCity.value.value}, ${activityStreet.value.value}`;
        exceptionMessage.value = 'Please enter valid house number';
        scrollToTop();
      }
    } catch (error) {
      // Обробка помилок, наприклад, у випадку невдалих запитів до API
      console.log('Error during fetching data for mapCenter from geocode.maps API:', error);
      exceptionTitle.value = `No such house number in ${activityCity.value.value}, ${activityStreet.value.value}`;
      exceptionMessage.value = 'Please enter valid house number';
      scrollToTop();
    }
  }else{
    activityCity.value.value = '';
    activityStreet.value.value = '';
    activityHouseNumber.value.value = '';
    exceptionTitle.value = 'Unselected city or street';
    exceptionMessage.value = 'Please select city and street, then enter valid house number';
    scrollToTop();
  }
}

// todo: add to storage
async function updateDataAfterMarkerDragged(lat, lon){
  try {
    const response  = await fetch(`https://geocode.maps.co/reverse?lat=${lat}&lon=${lon}&api_key=659450539ff1f762862410sea796255`);
    const data = await response.json();
    activityStreet.value.value = data.address.road;
    activityHouseNumber.value.value = data.address.house_number ? data.address.house_number : "";
  } catch (error) {
    console.log('Error during dragging the marker:', error);
  }
}

// todo: add to storage
const updateMarkerLatLng = async (event) => {
  const updatedMarkerCoordinates = event.target.getLatLng();
  markerLat.value = updatedMarkerCoordinates.lat;
  markerLng.value = updatedMarkerCoordinates.lng;
  await updateDataAfterMarkerDragged(updatedMarkerCoordinates.lat, updatedMarkerCoordinates.lng);
}

// todo: make handle form reset
</script>

<style scoped>
/* form-container ------------------------------------------------------*/
.form-container{
  margin: 24px auto 40px auto;
  padding: 0 15px;
}

.form-item-container{
  margin-bottom: 8px;
}

.leafletMapContainer{
  height: 400px;
  margin-bottom: 24px;
}

.form-datepicker-container{
  margin-bottom: 22px;
}

.form-header{
  margin-bottom: 20px;
}

/* make RWD  -----------------------------------------------------------------*/
@media (max-width: 430px) {
  ._container{
    padding: 0 10px 0 10px;
  }

  .form-container{
    margin-top: 16px;
    width: 300px;
    padding: 0 0;
  }
}

@media (min-width: 1000px) {
  .form-container{
    width: 900px;
    background-color: white;
    border-radius: 15px;
    padding: 15px 15px 25px 15px;


    /* shadow */
   -webkit-box-shadow: 8px 8px 42px -20px rgba(66, 68, 90, 1);
   -moz-box-shadow: 8px 8px 42px -20px rgba(66, 68, 90, 1);
   box-shadow: 8px 8px 42px -20px rgba(66, 68, 90, 1);
  }

  .flex-container{
    display: flex;
    justify-content: space-between;
  }

  .left-group-container{
    width: 300px;
  }

  .leafletMapContainer{
    height: 320px;
    width: 550px;
  }
}

/* activity-added-container --------------------------------------------------*/
.activity-added-container{
  margin: 60px auto 50px auto;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  width: 450px;
  height: 350px;
  border-radius: 15px;

  /* shadow */
  -webkit-box-shadow: 8px 8px 42px -20px rgba(66, 68, 90, 1);
  -moz-box-shadow: 8px 8px 42px -20px rgba(66, 68, 90, 1);
  box-shadow: 8px 8px 42px -20px rgba(66, 68, 90, 1);
}

.activity-added-img{
  margin-bottom: 20px;
}

.form-added-success-img{
  width: 150px;
  height: 150px;
}

/* make RWD  --------------------------------------------------------------------*/
@media (max-width: 515px) {
  .activity-added-container{
    width: 320px;
  }
}
@media (max-width: 355px) {
  .activity-added-container{
    width: 290px;
  }
}

.my-error-message{
  margin-top: -10px;
  padding-left: 14px;
  line-height: 12px;
  transition-duration: 150ms;
  color: rgb(176, 0, 32);
  font-weight: 400;
  font-size: 12px;
}

.submit-button{
  background: #000;
  color: white;
}

.link-button{
  margin-top: 25px;
  background: #000;
}

.link-item{
  display: flex;
  justify-content: center;
  color: white;
}

.valid input,
.valid select,
.valid textarea,
.valid select{
  border: 1px solid green;
}

.error input,
.error select,
.error textarea,
.error select{
  border: 1px solid red;
}
</style>